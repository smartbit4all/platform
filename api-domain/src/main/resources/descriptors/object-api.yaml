openapi: 3.0.3
info:
  title: Object api
  description: |
    The object api responsible for the domain object meta information including the object definitions
    and the relations among them. These objects are stored because the modules can contribute. The modules
    have their own ObjectApi that manages the storage and ensure the up-to-date view of the current data.
    The algorithms are running on the ObjectApi cache refreshed periodically.
  termsOfService: ''
  contact:
    email: info@it4all.hu
  version: 1.0.0
tags:
  - name: Object
    description: Object
paths: {}
components:
  schemas:
    ObjectDefinitionData:
      type: object
      description: |
        The object definition can be defined by some API definition language like OpenApi or so. On the backend the result is java class that describes all
        the properties and contained object definitions also.
      required: [uri, qualifiedName, properties, outgoingReferences]
      properties:
        uri:
          type: string
          format: uri
          description: |
            The storage identifier of the given definition. It is calculated by the qualified name of the object. For example 
            object:/com/smartbit4all/mydomain/model/MyObject could be a calculated URI for a given reference. The object definition
        qualifiedName:
          type: string
        keyProperty:
          type: string
          description: |
            The name of the uri property that is the referential resource identifier for the object instances. Normally it is the
            uri but if the object does not have uri (identity in the storage level) then it can be the unique identifier or code also. 
        properties:
          type: array
          items:
            $ref: '#/components/schemas/PropertyDefinitionData'
        outgoingReferences:
          type: array
          items:
            $ref: '#/components/schemas/ReferenceDefinitionData'
    PropertyDefinitionData:
      type: object
      description: |
        The property definition can be defined by some API definition language like OpenApi or so. On the backend the result is java class that describes all
        the properties and contained object definitions also. This definition is responsible for the properties.
      required: [uri, name, typeClass]
      properties:
        uri:
          type: string
          format: uri
          description: |
            The storage identifier of the given definition. It is calculated by the qualified name of the object. For example 
            object:/org/smartbit4all/mydomain/model/MyObject/firstProperty could be a calculated URI for a given reference. If the property is defined dynamically
            then the URI is a standard URI.
        name:
          type: string
          description: The property name.
        typeClass:
          type: string
          description: |
            The qualified name of the type class in java. Like java.lang.String If we need to convert this type to any other platform then
            we need a conversion for this. If the type is primitive type (String, Long, Integer, etc.) then it is a value as is but if it has definition on
            its own then it is a complex type with inner properties as well. 
        referredType:
          type: string
          description: |
            If the given property is mapped to a referred property then this is the name of the referred type.
        referredPropertyName:
          type: string
          description: |
            If the given property is mapped to a referred property then this is the name of the referred property inside the referred type.
            If we do not set the name of the property then it is the unique identifier of the referredType. If it has URI then it is the
            URI else it is the 
        defaultValue:
          type: object
          description: The default value that must be the same type as the property itself.
        widget:
          type: SmartWidgetDefinition
          description: |
            The default widget definition for the given property. It can be empty but in this case we must have another option to setup the
            widget for a layout.
        valueSet:
          type: string
          format: uri
          description: |
            The default value set schema for the given property. It can overridden at object definition level and can
            be specified also at objkect instance level. It is not required if empty then the value set is global.
    ReferenceDefinitionData:
      type: object
      description: |
        The reference definition is a directed navigation between objects. Its name is unique inside the source object that can have only one
        outgoing reference with the same name. In the target object the source object and the name is unique together but the name itself is not
        enough to identify an incoming reference.
      required: [uri, sourceObjectName, propertyPath, aggregation, multiplicity] 
      properties:
        uri:
          type: string
          format: uri
          description: |
            The storage identifier of the given definition. It is calculated by the qualified name of the object and the name name of the
            reference. For example object:/com/smartbit4all/mydomain/model/MyObject/firstReference could be a calculated URI for a given reference.
            By default it could be a good idea to name the reference by the name of the property that contains the reference value.
        backReference:
          type: string
          format: uri
          description: If an association between two object is navigable into both direction then this uri refers to the opposite reference.
        sourceObjectName:
          type: string
          description: The qualified name of the source object.
        propertyPath:
          description:  |
            The descriptor of a property in a domain object. If there is a simple property then we have only the path. The path is a navigation path to
            identify the property in the object or in its contained objects. The path can be "parent" if the parent property is directly a property inside the
            object. It can be myContained/parent if it is the propery of the myContained object. The property must be an uri or unique identifier to be able to 
            access the object directly by its value.
            If we have an array the the array path contains the path of the array property in the same way. The array must contains uri / identifier values.
          type: string
        targetObjectName:
          type: string
          description: The name of the target object.
        targetValueSet:
          type: string
          format: uri
          description: If the given reference points to a value set then this uri contains the reference.
        aggregation:
          $ref: '#/components/schemas/AggregationKind'
        propertyKind:
          $ref: '#/components/schemas/ReferencePropertyKind'
    AggregationKind:
      type: string
      description: |
        COMPOSITE means that the source contains the target object. The target object is accessible 
        only from the source. NONE means normal reference, no composition. SHARED is not implemented yet.
      default: none
      enum: [none, shared, composite, inline]
    ReferencePropertyKind:
      type: string
      enum: [reference, list, map]
    ObjectNodeData:
      type: object
      description: |
        This object contains an object instance as map. It can be used to separate the references and the business data in the API implementations. The object node contains 
        an object returned by the RetrievalApi. It can manage the state of the object and we can use it to produce ApplyChangeRequest at the end of the modification.
      required: [qualifiedName, versionNr, state, objectAsMap, references, referenceLists, referenceMaps] 
      properties:
        objectUri:
          type: string
          format: uri
          description: |
            The object URI of the given object state. It is version URI to be able to refere to the given version of the data.
        qualifiedName:
          type: string
          description: |
            The qualified globaly unique name of the object definition. In a java application it is the qualified name of the class.
        storageSchema:
          type: string
          description: |
            The logical storage scheme if it is used in the given storage implementation.
        versionNr:
          type: integer
          format: int64
          default: 0
          description: |
            The version number of the given node. It is filled by the retrieve so if we create a new node
            then it is 0 by default.
        lastModified:
          type: integer
          format: int64
          default: -1
          description: |
            The last modification time in long. It is filled by the retrieve so if we create a new node then it is 
            -1 by default.
        state:
          $ref: '#/components/schemas/ObjectNodeState'
        objectAsMap:
          type: object
          additionalProperties: true
        references:
          type: ObjectNodeData
          additionalProperties:
            $ref: '#/components/schemas/ObjectNodeData'
        referenceLists:
          type: ObjectNodeData
          additionalProperties:
            type: array
            items:
              $ref: '#/components/schemas/ObjectNodeData'
        referenceMaps:
          type: object
          additionalProperties:
            type: object
            additionalProperties:
              $ref: '#/components/schemas/ObjectNodeData'
        resultUri:
          type: string
          format: uri
          description: |
            The object URI after an ObjectApi.save. It can be used to read the result Uri after save.
    ObjectNodeState:
      type: string
      default: NOP
      enum: [NOP, NEW, MODIFIED, REMOVED]
    RetrievalMode:
      type: string
      default: NORMAL
      enum: [NORMAL, LATEST, EXACT_VERSION]
    SnapshotEntry:
      type: object
      description: |
        A snapshot is similar to an ObjectNodeData. It can be saved, and contains only one inline 
        object (SnapshotData) - it only contains versioned URIs and references. 
        Since these versions don't change, a snapshot can always be reloaded exactly as it was before.
      properties:
        uri:
          type: string
          format: uri
        data:
          $ref: '#/components/schemas/SnapshotData'
    SnapshotData:
      type: object
      description: 
      required: [references, referenceLists, referenceMaps] 
      properties:
        objectUri:
          type: string
          format: uri
        qualifiedName:
          type: string
        storageSchema:
          type: string
        versionNr:
          type: integer
          format: int64
        objectAsMap:
          type: object
          additionalProperties: true
        references:
          type: string
          additionalProperties:
            $ref: '#/components/schemas/SnapshotDataRef'
        referenceLists:
          type: string
          additionalProperties:
            type: array
            items:
              $ref: '#/components/schemas/SnapshotDataRef'
        referenceMaps:
          type: string
          additionalProperties:
            type: string
            additionalProperties:
              $ref: '#/components/schemas/SnapshotDataRef'
        resultUri:
          type: string
          format: uri
          description: |
            The object URI after an ObjectApi.save. It can be used to read the result Uri after save.
    SnapshotDataRef:
      type: object
      description: 
      properties:
        objectUri:
          type: string
          format: uri
        isLoaded:
          type: boolean
        data:
          $ref: '#/components/schemas/SnapshotData'
    ObjectChangeData:
      type: object
      description: |
        The changes between two object structure. The change is based on the property names and computed by the value map of
        the object.
      required: [properties, references]
      properties:
        typeClass:
          type: string
          description: The name of the type class if exists.
        properties:
          type: array
          items:
            $ref: '#/components/schemas/PropertyChangeData'
        references:
          type: array
          items:
            $ref: '#/components/schemas/ReferenceChangeData'
    PropertyChangeData:
      type: object
      description: |
        The change of a property with the path as an identifier. The old value and the new value is also available as Object but
        we need to handle it as String after a serialization and deserialization.
      required: [path]
      properties:
        path:
          type: string
          description: The path identify the given property inside the object.
        oldValue:
          type: object
        newValue:
          type: object          
    ReferenceChangeData:
      type: object
      description: |
        The change of a reference in and object as another object change.
      required: [path]
      properties:
        path:
          type: string
          description: The path identify the given property inside the object.
        objectChange:
          $ref: '#/components/schemas/ObjectChangeData'
    TableDataContent:
      type: object
      description: |
        This object is a table data with column definitions as header and rows. The rows are map of objects with the
        property names defined in the header.
      required: [header, totalRowCount, rows]
      properties:
        header:
          $ref: '#/components/schemas/TableDataContentHeader'
        totalRowCount:
          type: integer
          format: int32
        rows:
          type: array
          items:
            $ref: '#/components/schemas/TableDataContentRow'
    TableDataContentRow:
      type: object
      description: |
        This object is a table data row containening the identifier and actions releted with the row.
      required: [actions]
      properties:
        data:
          type: object
    TableDataContentHeader:
      type: object
      description: |
        This object is a table data header that defines the columns of the table data.
      required: [columns]
      properties:
        columns:
          type: array
          items:
            $ref: '#/components/schemas/TableDataContentColumn'
    TableDataContentColumn:
      type: object
      required: [label, propertyName]
      properties:
        label:
          type: string
        propertyName:
          type: string
        typeClass:
          type: string
    ObjectContainer:
      type: object
      required: [uri]
      properties:
        uri:
          type: string
          format: uri
        data:
          type: object
    ObjectPropertyResolverContext:
      type: object
      description: |
        The context objects of a property value resolution.
      required: [objects]
      properties:
        objects:
          type: array
          items:
            $ref: '#/components/schemas/ObjectPropertyResolverContextObject'
    ObjectPropertyResolverContextObject:
      type: object
      description: |
        The context object of a property value resolution with the name of the object in the given context and the uri of this.
      properties:
        name:
          type: string
        uri:
          type: string
          format: uri
    BranchEntry:
      type: object
      description: |
        The branch entry is used to identify the changes of the objects in on a branch. The object can be constructed and 
        saved without any operation. If the original object is saved on this branch then the operation is registered into 
        this object and executed directly.
      required: [uri, created, branchedObjects, newObjects, deletedObjects]
      properties:
        uri:
          type: string
          format: uri
          description: The uri of the object.
        caption:
          type: string
          description: |
            The branch could be used as business domain object. If we collect the versions of an object then useng the
            caption we can identify the intent of the modification.
        created:
          type: UserActivityLog
        lockedBy:
          type: UserActivityLog
        branchedObjects:
          type: object
          description: The branched objects are identified by the latest URI of the source object.
          additionalProperties:
            $ref: '#/components/schemas/BranchedObject'
        newObjects:
          type: object
          description: The branched objects are identified by the latest URI of the new branch object.
          additionalProperties:
            $ref: '#/components/schemas/BranchedObject'
        deletedObjects:
          type: object
          description: |
            The version uri of the deleted object identified by the latest URI. The version uri is important to
            be able check if we still have the same version when merging. The deletion on a branch is a global option. 
            So if we have multiple references to the deleted object then the ObjectApi will hide the deleted object from a 
            referring list. But we have to make the modification before the merge or during the merge to commit the deletionm of the
            the given object!
          additionalProperties:
            type: string
            format: uri
    BranchedObject:
      type: object
      description: |
        The object branch data is used to hold all the operations about an object on a branch. This object is
        constructed when the first opartion is executed with the given object.
      required: [objectUri, operations]
      properties:
        sourceObjectLatestUri:
          type: string
          description: The latest uri of the source object.
          format: uri
        branchedObjectLatestUri:
          type: string
          description: The latest uri of the branched object.
          format: uri
        operations:
          type: array
          description: |
            The init, rebase and merge operations of the branched object. The init is the original construction
            of the branched object. The rebase is accepting the new version from the source and the merge is the 
            publishing the branched version as a new source version.
          items: 
            $ref: '#/components/schemas/BranchOperation'
    BranchOperation:
      type: object
      description: |
        The data of the operation in a branch.
      required: [sourceUri, targetUri, operationType]
      properties:
        sourceUri:
          type: string
          format: uri
        targetUri:
          type: string
          format: uri
        operationType:
          type: string
          enum: [init, rebase, merge]
        executedAt:
          type: UserActivityLog
        operation:
          type: string
          description: The Api and the operation that was created the given version of the object.
    BranchedObjectEntry:
      type: object
      description: |
        The entry stands for an object in a collection that is branched. The entry can be a new one, modified, deleted or nop - unmodified.
        It has reference for the original and the branched uri sor we can follow tha two uri to access both.
      properties:
        branchingState:
          enum: [NOP, NEW, MODIFIED, DELETED]
        originalUri:
          type: string
          format: uri
        branchUri:
          type: string
          format: uri
