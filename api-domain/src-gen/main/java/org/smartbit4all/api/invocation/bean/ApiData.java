/*
 * invocation api
 * The invocation api is a generic possibility to call remote apis.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.invocation.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import org.smartbit4all.api.invocation.bean.MethodData;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * An api is a programming interface consists of methods to call. An api can be provided by many deployment units at the same time. When a deployment unit starts it collects all the apis and methods it has and register it into the storage. If another deployment unit has a registration for this api as a remote proxy then this proxy is going to be initiated and will be able to call the newly started node. If we have a primary api that collects the available secondary apis of an interface then the primary api local instances will be notified about the availability of the given interface instance. The remote registration is not saved here to avoid circular references. 
 */
@ApiModel(description = "An api is a programming interface consists of methods to call. An api can be provided by many deployment units at the same time. When a deployment unit starts it collects all the apis and methods it has and register it into the storage. If another deployment unit has a registration for this api as a remote proxy then this proxy is going to be initiated and will be able to call the newly started node. If we have a primary api that collects the available secondary apis of an interface then the primary api local instances will be notified about the availability of the given interface instance. The remote registration is not saved here to avoid circular references. ")
@JsonPropertyOrder({
  ApiData.URI,
  ApiData.INTERFACE_NAME,
  ApiData.NAME,
  ApiData.METHODS
})
@JsonTypeName("ApiData")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ApiData {
  public static final String URI = "uri";
  private URI uri;

  public static final String INTERFACE_NAME = "interfaceName";
  private String interfaceName;

  public static final String NAME = "name";
  private String name;

  public static final String METHODS = "methods";
  private List<MethodData> methods = new ArrayList<>();


  public ApiData uri(URI uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * Get uri
   * @return uri
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public URI getUri() {
    return uri;
  }


  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUri(URI uri) {
    this.uri = uri;
  }


  public ApiData interfaceName(String interfaceName) {
    
    this.interfaceName = interfaceName;
    return this;
  }

   /**
   * The fully qualified name of the api interface. In case of java it is the name of the interface. There can be more than one implementation from an interface class provided by one or more module. But they have to have a unique name in this case. 
   * @return interfaceName
  **/
  @javax.annotation.Nonnull
  @NotNull
  @ApiModelProperty(required = true, value = "The fully qualified name of the api interface. In case of java it is the name of the interface. There can be more than one implementation from an interface class provided by one or more module. But they have to have a unique name in this case. ")
  @JsonProperty(INTERFACE_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getInterfaceName() {
    return interfaceName;
  }


  @JsonProperty(INTERFACE_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setInterfaceName(String interfaceName) {
    this.interfaceName = interfaceName;
  }


  public ApiData name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The name of the instance that is equal to the name of the interface if we have only one instance. But if we have more than one provided implementation than it is uniquely identify them. Normally in java spring application this is the name of the service. It is useful when we have multiple secondary apis registered and the primary api is going to collect them all. 
   * @return name
  **/
  @javax.annotation.Nonnull
  @NotNull
  @ApiModelProperty(required = true, value = "The name of the instance that is equal to the name of the interface if we have only one instance. But if we have more than one provided implementation than it is uniquely identify them. Normally in java spring application this is the name of the service. It is useful when we have multiple secondary apis registered and the primary api is going to collect them all. ")
  @JsonProperty(NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(String name) {
    this.name = name;
  }


  public ApiData methods(List<MethodData> methods) {
    
    this.methods = methods;
    return this;
  }

  public ApiData addMethodsItem(MethodData methodsItem) {
    this.methods.add(methodsItem);
    return this;
  }

   /**
   * The available methods of the given api interface. All of the methods in the interface are provided by default. If we need limited interface then we need to create this interface and publish it. 
   * @return methods
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The available methods of the given api interface. All of the methods in the interface are provided by default. If we need limited interface then we need to create this interface and publish it. ")
  @JsonProperty(METHODS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<MethodData> getMethods() {
    return methods;
  }


  @JsonProperty(METHODS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMethods(List<MethodData> methods) {
    this.methods = methods;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ApiData apiData = (ApiData) o;
    return Objects.equals(this.uri, apiData.uri) &&
        Objects.equals(this.interfaceName, apiData.interfaceName) &&
        Objects.equals(this.name, apiData.name) &&
        Objects.equals(this.methods, apiData.methods);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, interfaceName, name, methods);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ApiData {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    interfaceName: ").append(toIndentedString(interfaceName)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    methods: ").append(toIndentedString(methods)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

