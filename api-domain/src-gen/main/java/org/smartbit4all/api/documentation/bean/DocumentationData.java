/*
 * documentation api
 * The documentation is a basic structure for constructing hyper linked documentations. This data type and the managing api and UI panels can be used in every application for complex dokumentation. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.documentation.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import java.util.ArrayList;
import java.util.List;
import org.smartbit4all.api.documentation.bean.ParagraphData;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The documentation is a complex datatype that is always contained by a domain object. The documentation is usually a property and it has an ordered paragraph list. The flexibility comes from the types of the paragraphs because each paragraphs are managed as identified object and can be referred from other documentations. The documentation itself does not contain any chapter. It is a plain document section containing text paragraphs, pictures, Word documents as content, lists and tables. And later on this component set can be extended with any other data types that produces a textual documentation. The documentation has uri and can be referred as paragraph from another documentation. 
 */
@ApiModel(description = "The documentation is a complex datatype that is always contained by a domain object. The documentation is usually a property and it has an ordered paragraph list. The flexibility comes from the types of the paragraphs because each paragraphs are managed as identified object and can be referred from other documentations. The documentation itself does not contain any chapter. It is a plain document section containing text paragraphs, pictures, Word documents as content, lists and tables. And later on this component set can be extended with any other data types that produces a textual documentation. The documentation has uri and can be referred as paragraph from another documentation. ")
@JsonPropertyOrder({
  DocumentationData.URI,
  DocumentationData.CONTAINER_OBJECT_URI,
  DocumentationData.CONTAINER_PROPERTY_NAME,
  DocumentationData.PARAGRAPHS
})
@JsonTypeName("DocumentationData")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class DocumentationData {
  public static final String URI = "uri";
  private URI uri;

  public static final String CONTAINER_OBJECT_URI = "containerObjectUri";
  private URI containerObjectUri;

  public static final String CONTAINER_PROPERTY_NAME = "containerPropertyName";
  private String containerPropertyName;

  public static final String PARAGRAPHS = "paragraphs";
  private List<ParagraphData> paragraphs = new ArrayList<>();


  public DocumentationData uri(URI uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * Get uri
   * @return uri
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public URI getUri() {
    return uri;
  }


  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUri(URI uri) {
    this.uri = uri;
  }


  public DocumentationData containerObjectUri(URI containerObjectUri) {
    
    this.containerObjectUri = containerObjectUri;
    return this;
  }

   /**
   * The documentation is always contained by a container object.
   * @return containerObjectUri
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "The documentation is always contained by a container object.")
  @JsonProperty(CONTAINER_OBJECT_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public URI getContainerObjectUri() {
    return containerObjectUri;
  }


  @JsonProperty(CONTAINER_OBJECT_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContainerObjectUri(URI containerObjectUri) {
    this.containerObjectUri = containerObjectUri;
  }


  public DocumentationData containerPropertyName(String containerPropertyName) {
    
    this.containerPropertyName = containerPropertyName;
    return this;
  }

   /**
   * The name of the property from the container object.
   * @return containerPropertyName
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The name of the property from the container object.")
  @JsonProperty(CONTAINER_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getContainerPropertyName() {
    return containerPropertyName;
  }


  @JsonProperty(CONTAINER_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContainerPropertyName(String containerPropertyName) {
    this.containerPropertyName = containerPropertyName;
  }


  public DocumentationData paragraphs(List<ParagraphData> paragraphs) {
    
    this.paragraphs = paragraphs;
    return this;
  }

  public DocumentationData addParagraphsItem(ParagraphData paragraphsItem) {
    this.paragraphs.add(paragraphsItem);
    return this;
  }

   /**
   * The ordered list of paragraph references. The references are different kinds from the contained rich text to the referred other paragraph.   
   * @return paragraphs
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The ordered list of paragraph references. The references are different kinds from the contained rich text to the referred other paragraph.   ")
  @JsonProperty(PARAGRAPHS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<ParagraphData> getParagraphs() {
    return paragraphs;
  }


  @JsonProperty(PARAGRAPHS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setParagraphs(List<ParagraphData> paragraphs) {
    this.paragraphs = paragraphs;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    DocumentationData documentationData = (DocumentationData) o;
    return Objects.equals(this.uri, documentationData.uri) &&
        Objects.equals(this.containerObjectUri, documentationData.containerObjectUri) &&
        Objects.equals(this.containerPropertyName, documentationData.containerPropertyName) &&
        Objects.equals(this.paragraphs, documentationData.paragraphs);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, containerObjectUri, containerPropertyName, paragraphs);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class DocumentationData {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    containerObjectUri: ").append(toIndentedString(containerObjectUri)).append("\n");
    sb.append("    containerPropertyName: ").append(toIndentedString(containerPropertyName)).append("\n");
    sb.append("    paragraphs: ").append(toIndentedString(paragraphs)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

