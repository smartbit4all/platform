/*
 * storage api
 * The storage api is a generic possibility to store and load objects.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.storage.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import org.smartbit4all.api.storage.bean.ObjectVersion;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * When analysing the history the StorageApi creates a list of history entries for every version of the objects participates in the related history. It can contain the object data changes without relation versions. These are the significant versions that mean adat modification. 
 */
@ApiModel(description = "When analysing the history the StorageApi creates a list of history entries for every version of the objects participates in the related history. It can contain the object data changes without relation versions. These are the significant versions that mean adat modification. ")
@JsonPropertyOrder({
  ObjectHistoryEntry.SUMMARY,
  ObjectHistoryEntry.CHANGES,
  ObjectHistoryEntry.VERSION_URI,
  ObjectHistoryEntry.OBJECT_TYPE,
  ObjectHistoryEntry.VERSION
})
@JsonTypeName("ObjectHistoryEntry")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ObjectHistoryEntry {
  public static final String SUMMARY = "summary";
  private String summary;

  public static final String CHANGES = "changes";
  private String changes;

  public static final String VERSION_URI = "versionUri";
  private URI versionUri;

  public static final String OBJECT_TYPE = "objectType";
  private String objectType;

  public static final String VERSION = "version";
  private ObjectVersion version;


  public ObjectHistoryEntry summary(String summary) {
    
    this.summary = summary;
    return this;
  }

   /**
   * The summary of the history record constructed from the natural identifiers of the object. 
   * @return summary
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The summary of the history record constructed from the natural identifiers of the object. ")
  @JsonProperty(SUMMARY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getSummary() {
    return summary;
  }


  @JsonProperty(SUMMARY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSummary(String summary) {
    this.summary = summary;
  }


  public ObjectHistoryEntry changes(String changes) {
    
    this.changes = changes;
    return this;
  }

   /**
   * The changes rendered into a readable format. Every version produces some changes in the detal. This field contains these  in a summerized readable format. 
   * @return changes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The changes rendered into a readable format. Every version produces some changes in the detal. This field contains these  in a summerized readable format. ")
  @JsonProperty(CHANGES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getChanges() {
    return changes;
  }


  @JsonProperty(CHANGES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChanges(String changes) {
    this.changes = changes;
  }


  public ObjectHistoryEntry versionUri(URI versionUri) {
    
    this.versionUri = versionUri;
    return this;
  }

   /**
   * The uri of the object version that can be used to read the given version. 
   * @return versionUri
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The uri of the object version that can be used to read the given version. ")
  @JsonProperty(VERSION_URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public URI getVersionUri() {
    return versionUri;
  }


  @JsonProperty(VERSION_URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setVersionUri(URI versionUri) {
    this.versionUri = versionUri;
  }


  public ObjectHistoryEntry objectType(String objectType) {
    
    this.objectType = objectType;
    return this;
  }

   /**
   * The object type of the history entry. A list of history entry can contain multiple types if their versions are involved. 
   * @return objectType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The object type of the history entry. A list of history entry can contain multiple types if their versions are involved. ")
  @JsonProperty(OBJECT_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getObjectType() {
    return objectType;
  }


  @JsonProperty(OBJECT_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setObjectType(String objectType) {
    this.objectType = objectType;
  }


  public ObjectHistoryEntry version(ObjectVersion version) {
    
    this.version = version;
    return this;
  }

   /**
   * Get version
   * @return version
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public ObjectVersion getVersion() {
    return version;
  }


  @JsonProperty(VERSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setVersion(ObjectVersion version) {
    this.version = version;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjectHistoryEntry objectHistoryEntry = (ObjectHistoryEntry) o;
    return Objects.equals(this.summary, objectHistoryEntry.summary) &&
        Objects.equals(this.changes, objectHistoryEntry.changes) &&
        Objects.equals(this.versionUri, objectHistoryEntry.versionUri) &&
        Objects.equals(this.objectType, objectHistoryEntry.objectType) &&
        Objects.equals(this.version, objectHistoryEntry.version);
  }

  @Override
  public int hashCode() {
    return Objects.hash(summary, changes, versionUri, objectType, version);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjectHistoryEntry {\n");
    sb.append("    summary: ").append(toIndentedString(summary)).append("\n");
    sb.append("    changes: ").append(toIndentedString(changes)).append("\n");
    sb.append("    versionUri: ").append(toIndentedString(versionUri)).append("\n");
    sb.append("    objectType: ").append(toIndentedString(objectType)).append("\n");
    sb.append("    version: ").append(toIndentedString(version)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

