/*
 * Object api
 * The object api responsible for the domain object meta information including the object definitions and the relations among them. These objects are stored because the modules can contribute. The modules have their own ObjectApi that manages the storage and ensure the up-to-date view of the current data. The algorithms are running on the ObjectApi cache refreshed periodically. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.object.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.smartbit4all.api.object.bean.BranchedObjectReference;
import org.smartbit4all.api.object.bean.ReferencePropertyKind;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The branched reference stands for a collection let it be collection api or objet ref / list or map. If we have a reference to a bunch of other objects then we can modify the references on the given branch. A references is alwaysa a copy so retrieving the proper objects on the branch is not a great challenge. But to know how what are the changes on the branch we need to know the reference operations. We can have new, deleted references and a referrred object can be modified also. If the given reference is new then we have to know if it is really a new object on the branch or not. The deleted means nothing from the perspective of the merge and the modification is implemented with a replace even if we refer the version or the latest. The uri of the branched objects is different they are copy of the source. 
 */
@ApiModel(description = "The branched reference stands for a collection let it be collection api or objet ref / list or map. If we have a reference to a bunch of other objects then we can modify the references on the given branch. A references is alwaysa a copy so retrieving the proper objects on the branch is not a great challenge. But to know how what are the changes on the branch we need to know the reference operations. We can have new, deleted references and a referrred object can be modified also. If the given reference is new then we have to know if it is really a new object on the branch or not. The deleted means nothing from the perspective of the merge and the modification is implemented with a replace even if we refer the version or the latest. The uri of the branched objects is different they are copy of the source. ")
@JsonPropertyOrder({
  BranchedContainerReference.CONTAINER_TYPE,
  BranchedContainerReference.REFERENCE_KIND,
  BranchedContainerReference.IDENTIFIER,
  BranchedContainerReference.NEW_OBJECTS,
  BranchedContainerReference.MODIFIED_OBJECTS,
  BranchedContainerReference.DELETED_OBJECTS
})
@JsonTypeName("BranchedContainerReference")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class BranchedContainerReference {
  /**
   * Gets or Sets containerType
   */
  public enum ContainerTypeEnum {
    COLLECTION("COLLECTION"),
    
    OBJECT("OBJECT");

    private String value;

    ContainerTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static ContainerTypeEnum fromValue(String value) {
      for (ContainerTypeEnum b : ContainerTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String CONTAINER_TYPE = "containerType";
  private ContainerTypeEnum containerType;

  public static final String REFERENCE_KIND = "referenceKind";
  private ReferencePropertyKind referenceKind;

  public static final String IDENTIFIER = "identifier";
  private String identifier;

  public static final String NEW_OBJECTS = "newObjects";
  private Map<String, BranchedObjectReference> newObjects = null;

  public static final String MODIFIED_OBJECTS = "modifiedObjects";
  private Map<String, BranchedObjectReference> modifiedObjects = null;

  public static final String DELETED_OBJECTS = "deletedObjects";
  private Map<String, BranchedObjectReference> deletedObjects = new HashMap<>();

  public BranchedContainerReference() { 
  }

  public BranchedContainerReference containerType(ContainerTypeEnum containerType) {
    
    this.containerType = containerType;
    return this;
  }

   /**
   * Get containerType
   * @return containerType
  **/
  @javax.annotation.Nonnull
  @NotNull
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(CONTAINER_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public ContainerTypeEnum getContainerType() {
    return containerType;
  }


  @JsonProperty(CONTAINER_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setContainerType(ContainerTypeEnum containerType) {
    this.containerType = containerType;
  }


  public BranchedContainerReference referenceKind(ReferencePropertyKind referenceKind) {
    
    this.referenceKind = referenceKind;
    return this;
  }

   /**
   * Get referenceKind
   * @return referenceKind
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(REFERENCE_KIND)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public ReferencePropertyKind getReferenceKind() {
    return referenceKind;
  }


  @JsonProperty(REFERENCE_KIND)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setReferenceKind(ReferencePropertyKind referenceKind) {
    this.referenceKind = referenceKind;
  }


  public BranchedContainerReference identifier(String identifier) {
    
    this.identifier = identifier;
    return this;
  }

   /**
   * This identifier looks like a special uri that identifies the references. It can be directly a collection api object that is easy to identify. But it can be URI of an object with the fragment that refers to the referencing container. For example the 
   * @return identifier
  **/
  @javax.annotation.Nonnull
  @NotNull
  @ApiModelProperty(required = true, value = "This identifier looks like a special uri that identifies the references. It can be directly a collection api object that is easy to identify. But it can be URI of an object with the fragment that refers to the referencing container. For example the ")
  @JsonProperty(IDENTIFIER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getIdentifier() {
    return identifier;
  }


  @JsonProperty(IDENTIFIER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIdentifier(String identifier) {
    this.identifier = identifier;
  }


  public BranchedContainerReference newObjects(Map<String, BranchedObjectReference> newObjects) {
    
    this.newObjects = newObjects;
    return this;
  }

  public BranchedContainerReference putNewObjectsItem(String key, BranchedObjectReference newObjectsItem) {
    if (this.newObjects == null) {
      this.newObjects = new HashMap<>();
    }
    this.newObjects.put(key, newObjectsItem);
    return this;
  }

   /**
   * The objects that are new in the given reference. The new can be a modified in the branch! It is new here but we add a reference to this on this branch.  
   * @return newObjects
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "The objects that are new in the given reference. The new can be a modified in the branch! It is new here but we add a reference to this on this branch.  ")
  @JsonProperty(NEW_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, BranchedObjectReference> getNewObjects() {
    return newObjects;
  }


  @JsonProperty(NEW_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setNewObjects(Map<String, BranchedObjectReference> newObjects) {
    this.newObjects = newObjects;
  }


  public BranchedContainerReference modifiedObjects(Map<String, BranchedObjectReference> modifiedObjects) {
    
    this.modifiedObjects = modifiedObjects;
    return this;
  }

  public BranchedContainerReference putModifiedObjectsItem(String key, BranchedObjectReference modifiedObjectsItem) {
    if (this.modifiedObjects == null) {
      this.modifiedObjects = new HashMap<>();
    }
    this.modifiedObjects.put(key, modifiedObjectsItem);
    return this;
  }

   /**
   * The objects that are modiefied in the given reference. These can be modified objects on its own but also it can be a contained object or a value.  
   * @return modifiedObjects
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "The objects that are modiefied in the given reference. These can be modified objects on its own but also it can be a contained object or a value.  ")
  @JsonProperty(MODIFIED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, BranchedObjectReference> getModifiedObjects() {
    return modifiedObjects;
  }


  @JsonProperty(MODIFIED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setModifiedObjects(Map<String, BranchedObjectReference> modifiedObjects) {
    this.modifiedObjects = modifiedObjects;
  }


  public BranchedContainerReference deletedObjects(Map<String, BranchedObjectReference> deletedObjects) {
    
    this.deletedObjects = deletedObjects;
    return this;
  }

  public BranchedContainerReference putDeletedObjectsItem(String key, BranchedObjectReference deletedObjectsItem) {
    this.deletedObjects.put(key, deletedObjectsItem);
    return this;
  }

   /**
   * The objects that are removed from the given container reference. It is important to know to be able to produce the full list of BranchedObjectEntry. There must be deleted BranchedObjectEntry also. But during the merge the deletion is not a special operation we simply forget the reference. 
   * @return deletedObjects
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The objects that are removed from the given container reference. It is important to know to be able to produce the full list of BranchedObjectEntry. There must be deleted BranchedObjectEntry also. But during the merge the deletion is not a special operation we simply forget the reference. ")
  @JsonProperty(DELETED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, BranchedObjectReference> getDeletedObjects() {
    return deletedObjects;
  }


  @JsonProperty(DELETED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDeletedObjects(Map<String, BranchedObjectReference> deletedObjects) {
    this.deletedObjects = deletedObjects;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BranchedContainerReference branchedContainerReference = (BranchedContainerReference) o;
    return Objects.equals(this.containerType, branchedContainerReference.containerType) &&
        Objects.equals(this.referenceKind, branchedContainerReference.referenceKind) &&
        Objects.equals(this.identifier, branchedContainerReference.identifier) &&
        Objects.equals(this.newObjects, branchedContainerReference.newObjects) &&
        Objects.equals(this.modifiedObjects, branchedContainerReference.modifiedObjects) &&
        Objects.equals(this.deletedObjects, branchedContainerReference.deletedObjects);
  }

  @Override
  public int hashCode() {
    return Objects.hash(containerType, referenceKind, identifier, newObjects, modifiedObjects, deletedObjects);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BranchedContainerReference {\n");
    sb.append("    containerType: ").append(toIndentedString(containerType)).append("\n");
    sb.append("    referenceKind: ").append(toIndentedString(referenceKind)).append("\n");
    sb.append("    identifier: ").append(toIndentedString(identifier)).append("\n");
    sb.append("    newObjects: ").append(toIndentedString(newObjects)).append("\n");
    sb.append("    modifiedObjects: ").append(toIndentedString(modifiedObjects)).append("\n");
    sb.append("    deletedObjects: ").append(toIndentedString(deletedObjects)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

