/*
 * Object api
 * The object api responsible for the domain object meta information including the object definitions and the relations among them. These objects are stored because the modules can contribute. The modules have their own ObjectApi that manages the storage and ensure the up-to-date view of the current data. The algorithms are running on the ObjectApi cache refreshed periodically. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.object.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The entry stands for an object in a collection that is branched. The entry can be a new one, modified, deleted or nop - unmodified. It has reference for the original and the branched uri sor we can follow tha two uri to access both. 
 */
@ApiModel(description = "The entry stands for an object in a collection that is branched. The entry can be a new one, modified, deleted or nop - unmodified. It has reference for the original and the branched uri sor we can follow tha two uri to access both. ")
@JsonPropertyOrder({
  BranchedObjectEntry.BRANCHING_STATE,
  BranchedObjectEntry.ORIGINAL_URI,
  BranchedObjectEntry.BRANCH_URI
})
@JsonTypeName("BranchedObjectEntry")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class BranchedObjectEntry {
  /**
   * Gets or Sets branchingState
   */
  public enum BranchingStateEnum {
    NOP("NOP"),
    
    NEW("NEW"),
    
    MODIFIED("MODIFIED"),
    
    DELETED("DELETED");

    private String value;

    BranchingStateEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static BranchingStateEnum fromValue(String value) {
      for (BranchingStateEnum b : BranchingStateEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String BRANCHING_STATE = "branchingState";
  private BranchingStateEnum branchingState;

  public static final String ORIGINAL_URI = "originalUri";
  private URI originalUri;

  public static final String BRANCH_URI = "branchUri";
  private URI branchUri;

  public BranchedObjectEntry() { 
  }

  public BranchedObjectEntry branchingState(BranchingStateEnum branchingState) {
    
    this.branchingState = branchingState;
    return this;
  }

   /**
   * Get branchingState
   * @return branchingState
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(BRANCHING_STATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public BranchingStateEnum getBranchingState() {
    return branchingState;
  }


  @JsonProperty(BRANCHING_STATE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBranchingState(BranchingStateEnum branchingState) {
    this.branchingState = branchingState;
  }


  public BranchedObjectEntry originalUri(URI originalUri) {
    
    this.originalUri = originalUri;
    return this;
  }

   /**
   * Get originalUri
   * @return originalUri
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(ORIGINAL_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public URI getOriginalUri() {
    return originalUri;
  }


  @JsonProperty(ORIGINAL_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOriginalUri(URI originalUri) {
    this.originalUri = originalUri;
  }


  public BranchedObjectEntry branchUri(URI branchUri) {
    
    this.branchUri = branchUri;
    return this;
  }

   /**
   * Get branchUri
   * @return branchUri
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(BRANCH_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public URI getBranchUri() {
    return branchUri;
  }


  @JsonProperty(BRANCH_URI)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBranchUri(URI branchUri) {
    this.branchUri = branchUri;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BranchedObjectEntry branchedObjectEntry = (BranchedObjectEntry) o;
    return Objects.equals(this.branchingState, branchedObjectEntry.branchingState) &&
        Objects.equals(this.originalUri, branchedObjectEntry.originalUri) &&
        Objects.equals(this.branchUri, branchedObjectEntry.branchUri);
  }

  @Override
  public int hashCode() {
    return Objects.hash(branchingState, originalUri, branchUri);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BranchedObjectEntry {\n");
    sb.append("    branchingState: ").append(toIndentedString(branchingState)).append("\n");
    sb.append("    originalUri: ").append(toIndentedString(originalUri)).append("\n");
    sb.append("    branchUri: ").append(toIndentedString(branchUri)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

