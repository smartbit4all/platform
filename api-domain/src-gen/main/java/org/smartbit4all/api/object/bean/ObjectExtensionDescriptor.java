/*
 * Object api
 * The object api responsible for the domain object meta information including the object definitions and the relations among them. These objects are stored because the modules can contribute. The modules have their own ObjectApi that manages the storage and ensure the up-to-date view of the current data. The algorithms are running on the ObjectApi cache refreshed periodically. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.object.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.smartbit4all.api.formdefinition.bean.SmartLayoutDefinition;
import org.smartbit4all.api.object.bean.ObjectConstraintDescriptor;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The extension descriptor defines the data layout of an object. The properties can be any DocumentProperty available as built in or extension properties. These properties are organized into layouts. The layouts are named to be able to identify the placeholder on the page. The extension contains the constraint and rule definitions for the given object let it be document or folder. 
 */
@ApiModel(description = "The extension descriptor defines the data layout of an object. The properties can be any DocumentProperty available as built in or extension properties. These properties are organized into layouts. The layouts are named to be able to identify the placeholder on the page. The extension contains the constraint and rule definitions for the given object let it be document or folder. ")
@JsonPropertyOrder({
  ObjectExtensionDescriptor.URI,
  ObjectExtensionDescriptor.NAME,
  ObjectExtensionDescriptor.LAYOUTS,
  ObjectExtensionDescriptor.PROPERTIES,
  ObjectExtensionDescriptor.CONSTRAINTS
})
@JsonTypeName("ObjectExtensionDescriptor")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class ObjectExtensionDescriptor {
  public static final String URI = "uri";
  private URI uri;

  public static final String NAME = "name";
  private String name;

  public static final String LAYOUTS = "layouts";
  private Map<String, SmartLayoutDefinition> layouts = new HashMap<>();

  public static final String PROPERTIES = "properties";
  private Map<String, URI> properties = new HashMap<>();

  public static final String CONSTRAINTS = "constraints";
  private List<ObjectConstraintDescriptor> constraints = null;

  public ObjectExtensionDescriptor() { 
  }

  public ObjectExtensionDescriptor uri(URI uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * Get uri
   * @return uri
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public URI getUri() {
    return uri;
  }


  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUri(URI uri) {
    this.uri = uri;
  }


  public ObjectExtensionDescriptor name(String name) {
    
    this.name = name;
    return this;
  }

   /**
   * The extension name is a unique and unmodifiable identifier of the given extension. It is used to construct dynamic object definitions so it must match with the requirements of the an object name (ANSI characters with no white spaces) 
   * @return name
  **/
  @javax.annotation.Nonnull
  @NotNull
  @ApiModelProperty(required = true, value = "The extension name is a unique and unmodifiable identifier of the given extension. It is used to construct dynamic object definitions so it must match with the requirements of the an object name (ANSI characters with no white spaces) ")
  @JsonProperty(NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(String name) {
    this.name = name;
  }


  public ObjectExtensionDescriptor layouts(Map<String, SmartLayoutDefinition> layouts) {
    
    this.layouts = layouts;
    return this;
  }

  public ObjectExtensionDescriptor putLayoutsItem(String key, SmartLayoutDefinition layoutsItem) {
    this.layouts.put(key, layoutsItem);
    return this;
  }

   /**
   * The layout definition for the object extension. The layouts are identified by their logical placeholder name that helps to identify the position of the given layout on the view. 
   * @return layouts
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The layout definition for the object extension. The layouts are identified by their logical placeholder name that helps to identify the position of the given layout on the view. ")
  @JsonProperty(LAYOUTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, SmartLayoutDefinition> getLayouts() {
    return layouts;
  }


  @JsonProperty(LAYOUTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLayouts(Map<String, SmartLayoutDefinition> layouts) {
    this.layouts = layouts;
  }


  public ObjectExtensionDescriptor properties(Map<String, URI> properties) {
    
    this.properties = properties;
    return this;
  }

  public ObjectExtensionDescriptor putPropertiesItem(String key, URI propertiesItem) {
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * The extension refers to included properties via reference but we store the properties mapped by their name to have a quick view about the available properties. If a property is included it appears in this list. If we place it into a layout then it is visible else it is invisible. 
   * @return properties
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The extension refers to included properties via reference but we store the properties mapped by their name to have a quick view about the available properties. If a property is included it appears in this list. If we place it into a layout then it is visible else it is invisible. ")
  @JsonProperty(PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, URI> getProperties() {
    return properties;
  }


  @JsonProperty(PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setProperties(Map<String, URI> properties) {
    this.properties = properties;
  }


  public ObjectExtensionDescriptor constraints(List<ObjectConstraintDescriptor> constraints) {
    
    this.constraints = constraints;
    return this;
  }

  public ObjectExtensionDescriptor addConstraintsItem(ObjectConstraintDescriptor constraintsItem) {
    if (this.constraints == null) {
      this.constraints = new ArrayList<>();
    }
    this.constraints.add(constraintsItem);
    return this;
  }

   /**
   * All the constraints that must be enforced the given object.
   * @return constraints
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "All the constraints that must be enforced the given object.")
  @JsonProperty(CONSTRAINTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<ObjectConstraintDescriptor> getConstraints() {
    return constraints;
  }


  @JsonProperty(CONSTRAINTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setConstraints(List<ObjectConstraintDescriptor> constraints) {
    this.constraints = constraints;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ObjectExtensionDescriptor objectExtensionDescriptor = (ObjectExtensionDescriptor) o;
    return Objects.equals(this.uri, objectExtensionDescriptor.uri) &&
        Objects.equals(this.name, objectExtensionDescriptor.name) &&
        Objects.equals(this.layouts, objectExtensionDescriptor.layouts) &&
        Objects.equals(this.properties, objectExtensionDescriptor.properties) &&
        Objects.equals(this.constraints, objectExtensionDescriptor.constraints);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, name, layouts, properties, constraints);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ObjectExtensionDescriptor {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    layouts: ").append(toIndentedString(layouts)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    constraints: ").append(toIndentedString(constraints)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

