/*
 * Object api
 * The object api responsible for the domain object meta information including the object definitions and the relations among them. These objects are stored because the modules can contribute. The modules have their own ObjectApi that manages the storage and ensure the up-to-date view of the current data. The algorithms are running on the ObjectApi cache refreshed periodically. 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.object.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.net.URI;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.smartbit4all.api.object.bean.BranchedContainerReference;
import org.smartbit4all.api.object.bean.BranchedObject;
import org.smartbit4all.api.session.bean.UserActivityLog;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The branch entry is used to identify the changes of the objects in on a branch. The object can be constructed and  saved without any operation. If the original object is saved on this branch then the operation is registered into  this object and executed directly. 
 */
@ApiModel(description = "The branch entry is used to identify the changes of the objects in on a branch. The object can be constructed and  saved without any operation. If the original object is saved on this branch then the operation is registered into  this object and executed directly. ")
@JsonPropertyOrder({
  BranchEntry.URI,
  BranchEntry.CAPTION,
  BranchEntry.CREATED,
  BranchEntry.LOCKED_BY,
  BranchEntry.BRANCHED_OBJECTS,
  BranchEntry.NEW_OBJECTS,
  BranchEntry.CONTAINER_REFERENCES
})
@JsonTypeName("BranchEntry")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class BranchEntry {
  public static final String URI = "uri";
  private URI uri;

  public static final String CAPTION = "caption";
  private String caption;

  public static final String CREATED = "created";
  private UserActivityLog created = null;

  public static final String LOCKED_BY = "lockedBy";
  private UserActivityLog lockedBy = null;

  public static final String BRANCHED_OBJECTS = "branchedObjects";
  private Map<String, BranchedObject> branchedObjects = new HashMap<>();

  public static final String NEW_OBJECTS = "newObjects";
  private Map<String, BranchedObject> newObjects = new HashMap<>();

  public static final String CONTAINER_REFERENCES = "containerReferences";
  private Map<String, BranchedContainerReference> containerReferences = null;

  public BranchEntry() { 
  }

  public BranchEntry uri(URI uri) {
    
    this.uri = uri;
    return this;
  }

   /**
   * The uri of the object.
   * @return uri
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The uri of the object.")
  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public URI getUri() {
    return uri;
  }


  @JsonProperty(URI)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUri(URI uri) {
    this.uri = uri;
  }


  public BranchEntry caption(String caption) {
    
    this.caption = caption;
    return this;
  }

   /**
   * The branch could be used as business domain object. If we collect the versions of an object then useng the caption we can identify the intent of the modification. 
   * @return caption
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The branch could be used as business domain object. If we collect the versions of an object then useng the caption we can identify the intent of the modification. ")
  @JsonProperty(CAPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getCaption() {
    return caption;
  }


  @JsonProperty(CAPTION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCaption(String caption) {
    this.caption = caption;
  }


  public BranchEntry created(UserActivityLog created) {
    
    this.created = created;
    return this;
  }

   /**
   * Get created
   * @return created
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "")
  @JsonProperty(CREATED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UserActivityLog getCreated() {
    return created;
  }


  @JsonProperty(CREATED)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCreated(UserActivityLog created) {
    this.created = created;
  }


  public BranchEntry lockedBy(UserActivityLog lockedBy) {
    
    this.lockedBy = lockedBy;
    return this;
  }

   /**
   * Get lockedBy
   * @return lockedBy
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(LOCKED_BY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public UserActivityLog getLockedBy() {
    return lockedBy;
  }


  @JsonProperty(LOCKED_BY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLockedBy(UserActivityLog lockedBy) {
    this.lockedBy = lockedBy;
  }


  public BranchEntry branchedObjects(Map<String, BranchedObject> branchedObjects) {
    
    this.branchedObjects = branchedObjects;
    return this;
  }

  public BranchEntry putBranchedObjectsItem(String key, BranchedObject branchedObjectsItem) {
    this.branchedObjects.put(key, branchedObjectsItem);
    return this;
  }

   /**
   * The branched objects are identified by the latest URI of the source object. These are the objects that are modified on the branch. It is important to know them because during the merge their uri references should be replaced with the merged uri of the source branch. 
   * @return branchedObjects
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The branched objects are identified by the latest URI of the source object. These are the objects that are modified on the branch. It is important to know them because during the merge their uri references should be replaced with the merged uri of the source branch. ")
  @JsonProperty(BRANCHED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, BranchedObject> getBranchedObjects() {
    return branchedObjects;
  }


  @JsonProperty(BRANCHED_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setBranchedObjects(Map<String, BranchedObject> branchedObjects) {
    this.branchedObjects = branchedObjects;
  }


  public BranchEntry newObjects(Map<String, BranchedObject> newObjects) {
    
    this.newObjects = newObjects;
    return this;
  }

  public BranchEntry putNewObjectsItem(String key, BranchedObject newObjectsItem) {
    this.newObjects.put(key, newObjectsItem);
    return this;
  }

   /**
   * The branched objects are identified by the latest URI of the new branch object.
   * @return newObjects
  **/
  @javax.annotation.Nonnull
  @NotNull
  @Valid
  @ApiModelProperty(required = true, value = "The branched objects are identified by the latest URI of the new branch object.")
  @JsonProperty(NEW_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, BranchedObject> getNewObjects() {
    return newObjects;
  }


  @JsonProperty(NEW_OBJECTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setNewObjects(Map<String, BranchedObject> newObjects) {
    this.newObjects = newObjects;
  }


  public BranchEntry containerReferences(Map<String, BranchedContainerReference> containerReferences) {
    
    this.containerReferences = containerReferences;
    return this;
  }

  public BranchEntry putContainerReferencesItem(String key, BranchedContainerReference containerReferencesItem) {
    if (this.containerReferences == null) {
      this.containerReferences = new HashMap<>();
    }
    this.containerReferences.put(key, containerReferencesItem);
    return this;
  }

   /**
   * The branched references identified by the unique identifier of the reference.
   * @return containerReferences
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "The branched references identified by the unique identifier of the reference.")
  @JsonProperty(CONTAINER_REFERENCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, BranchedContainerReference> getContainerReferences() {
    return containerReferences;
  }


  @JsonProperty(CONTAINER_REFERENCES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContainerReferences(Map<String, BranchedContainerReference> containerReferences) {
    this.containerReferences = containerReferences;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BranchEntry branchEntry = (BranchEntry) o;
    return Objects.equals(this.uri, branchEntry.uri) &&
        Objects.equals(this.caption, branchEntry.caption) &&
        Objects.equals(this.created, branchEntry.created) &&
        Objects.equals(this.lockedBy, branchEntry.lockedBy) &&
        Objects.equals(this.branchedObjects, branchEntry.branchedObjects) &&
        Objects.equals(this.newObjects, branchEntry.newObjects) &&
        Objects.equals(this.containerReferences, branchEntry.containerReferences);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uri, caption, created, lockedBy, branchedObjects, newObjects, containerReferences);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BranchEntry {\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    caption: ").append(toIndentedString(caption)).append("\n");
    sb.append("    created: ").append(toIndentedString(created)).append("\n");
    sb.append("    lockedBy: ").append(toIndentedString(lockedBy)).append("\n");
    sb.append("    branchedObjects: ").append(toIndentedString(branchedObjects)).append("\n");
    sb.append("    newObjects: ").append(toIndentedString(newObjects)).append("\n");
    sb.append("    containerReferences: ").append(toIndentedString(containerReferences)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

