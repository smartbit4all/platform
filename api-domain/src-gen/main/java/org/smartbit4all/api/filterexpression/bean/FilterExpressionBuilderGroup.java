/*
 * Filter API 2
 * Filter API 2
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: info@it4all.hu
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.smartbit4all.api.filterexpression.bean;

import java.util.Objects;
import java.util.Arrays;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import org.smartbit4all.api.filterexpression.bean.FilterExpressionBuilderField;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonTypeName;
import javax.validation.constraints.*;
import javax.validation.Valid;

/**
 * The group is just a UI structure to define a tree structure for the available filter fields. In a group there is an ordered list of filter fields. The group can imply a parenthesis in the xpression or an exist node. Theoreticaly the groups are hierarchical but the pratcticaly it is not. The kind of the group defines what operation is available for the filter fields in the group.  DISPLAY: means thet we can choose an available filter field from the group and place it into the field list related with the current group or in any sub list except under an exist. BRACKET: The given groups defines a bracket. If we choose any of the fiels to add to a filter list then this imlicitely create a bracket node. It can not be added under an exist node. EXIST: The same as the BRACKET but with an exist node. 
 */
@ApiModel(description = "The group is just a UI structure to define a tree structure for the available filter fields. In a group there is an ordered list of filter fields. The group can imply a parenthesis in the xpression or an exist node. Theoreticaly the groups are hierarchical but the pratcticaly it is not. The kind of the group defines what operation is available for the filter fields in the group.  DISPLAY: means thet we can choose an available filter field from the group and place it into the field list related with the current group or in any sub list except under an exist. BRACKET: The given groups defines a bracket. If we choose any of the fiels to add to a filter list then this imlicitely create a bracket node. It can not be added under an exist node. EXIST: The same as the BRACKET but with an exist node. ")
@JsonPropertyOrder({
  FilterExpressionBuilderGroup.LABEL,
  FilterExpressionBuilderGroup.BUILDER_GROUP_KIND,
  FilterExpressionBuilderGroup.FIELDS,
  FilterExpressionBuilderGroup.ROOT_LIST_ID,
  FilterExpressionBuilderGroup.SUB_GROUPS
})
@JsonTypeName("FilterExpressionBuilderGroup")
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen")
public class FilterExpressionBuilderGroup {
  public static final String LABEL = "label";
  private String label;

  /**
   * Defines if the given groups is just a visual sugar to group somehow the available filter fields or it is definetely a bracket or exists. 
   */
  public enum BuilderGroupKindEnum {
    DIPLAY("DIPLAY"),
    
    BRACKET("BRACKET"),
    
    EXIST("EXIST");

    private String value;

    BuilderGroupKindEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static BuilderGroupKindEnum fromValue(String value) {
      for (BuilderGroupKindEnum b : BuilderGroupKindEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String BUILDER_GROUP_KIND = "builderGroupKind";
  private BuilderGroupKindEnum builderGroupKind;

  public static final String FIELDS = "fields";
  private List<FilterExpressionBuilderField> fields = null;

  public static final String ROOT_LIST_ID = "rootListId";
  private String rootListId;

  public static final String SUB_GROUPS = "subGroups";
  private List<FilterExpressionBuilderGroup> subGroups = null;

  public FilterExpressionBuilderGroup() { 
  }

  public FilterExpressionBuilderGroup label(String label) {
    
    this.label = label;
    return this;
  }

   /**
   * The visual display name fo the group.
   * @return label
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The visual display name fo the group.")
  @JsonProperty(LABEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getLabel() {
    return label;
  }


  @JsonProperty(LABEL)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setLabel(String label) {
    this.label = label;
  }


  public FilterExpressionBuilderGroup builderGroupKind(BuilderGroupKindEnum builderGroupKind) {
    
    this.builderGroupKind = builderGroupKind;
    return this;
  }

   /**
   * Defines if the given groups is just a visual sugar to group somehow the available filter fields or it is definetely a bracket or exists. 
   * @return builderGroupKind
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Defines if the given groups is just a visual sugar to group somehow the available filter fields or it is definetely a bracket or exists. ")
  @JsonProperty(BUILDER_GROUP_KIND)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public BuilderGroupKindEnum getBuilderGroupKind() {
    return builderGroupKind;
  }


  @JsonProperty(BUILDER_GROUP_KIND)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBuilderGroupKind(BuilderGroupKindEnum builderGroupKind) {
    this.builderGroupKind = builderGroupKind;
  }


  public FilterExpressionBuilderGroup fields(List<FilterExpressionBuilderField> fields) {
    
    this.fields = fields;
    return this;
  }

  public FilterExpressionBuilderGroup addFieldsItem(FilterExpressionBuilderField fieldsItem) {
    if (this.fields == null) {
      this.fields = new ArrayList<>();
    }
    this.fields.add(fieldsItem);
    return this;
  }

   /**
   * Get fields
   * @return fields
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(FIELDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<FilterExpressionBuilderField> getFields() {
    return fields;
  }


  @JsonProperty(FIELDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFields(List<FilterExpressionBuilderField> fields) {
    this.fields = fields;
  }


  public FilterExpressionBuilderGroup rootListId(String rootListId) {
    
    this.rootListId = rootListId;
    return this;
  }

   /**
   * The unique identifier of the root list in the workplace.
   * @return rootListId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unique identifier of the root list in the workplace.")
  @JsonProperty(ROOT_LIST_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getRootListId() {
    return rootListId;
  }


  @JsonProperty(ROOT_LIST_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRootListId(String rootListId) {
    this.rootListId = rootListId;
  }


  public FilterExpressionBuilderGroup subGroups(List<FilterExpressionBuilderGroup> subGroups) {
    
    this.subGroups = subGroups;
    return this;
  }

  public FilterExpressionBuilderGroup addSubGroupsItem(FilterExpressionBuilderGroup subGroupsItem) {
    if (this.subGroups == null) {
      this.subGroups = new ArrayList<>();
    }
    this.subGroups.add(subGroupsItem);
    return this;
  }

   /**
   * Get subGroups
   * @return subGroups
  **/
  @javax.annotation.Nullable
  @Valid
  @ApiModelProperty(value = "")
  @JsonProperty(SUB_GROUPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<FilterExpressionBuilderGroup> getSubGroups() {
    return subGroups;
  }


  @JsonProperty(SUB_GROUPS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSubGroups(List<FilterExpressionBuilderGroup> subGroups) {
    this.subGroups = subGroups;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    FilterExpressionBuilderGroup filterExpressionBuilderGroup = (FilterExpressionBuilderGroup) o;
    return Objects.equals(this.label, filterExpressionBuilderGroup.label) &&
        Objects.equals(this.builderGroupKind, filterExpressionBuilderGroup.builderGroupKind) &&
        Objects.equals(this.fields, filterExpressionBuilderGroup.fields) &&
        Objects.equals(this.rootListId, filterExpressionBuilderGroup.rootListId) &&
        Objects.equals(this.subGroups, filterExpressionBuilderGroup.subGroups);
  }

  @Override
  public int hashCode() {
    return Objects.hash(label, builderGroupKind, fields, rootListId, subGroups);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class FilterExpressionBuilderGroup {\n");
    sb.append("    label: ").append(toIndentedString(label)).append("\n");
    sb.append("    builderGroupKind: ").append(toIndentedString(builderGroupKind)).append("\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    rootListId: ").append(toIndentedString(rootListId)).append("\n");
    sb.append("    subGroups: ").append(toIndentedString(subGroups)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

