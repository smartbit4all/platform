import { Component, Input } from '@angular/core';
import { SmartTableType } from './smarttable.model';
import * as i0 from "@angular/core";
import * as i1 from "@angular/material/table";
import * as i2 from "@angular/material/icon";
import * as i3 from "@angular/material/button";
import * as i4 from "@angular/material/menu";
import * as i5 from "@angular/material/checkbox";
import * as i6 from "@angular/common";
export class SmarttableComponent {
    constructor() {
        this.tableType = SmartTableType;
    }
    ngOnInit() { }
    isAllSelected() {
        const numSelected = this.smartTable.selection.selected.length;
        const numRows = this.smartTable.tableRows.length;
        return numSelected === numRows;
    }
    /** Selects all rows if they are not all selected; otherwise clear selection. */
    toggleAllRows() {
        if (this.isAllSelected()) {
            this.smartTable.selection.clear();
            return;
        }
        this.smartTable.selection.select(...this.smartTable.tableRows);
    }
    /** The label for the checkbox on the passed row */
    checkboxLabel(row) {
        if (!row) {
            return `${this.isAllSelected() ? 'deselect' : 'select'} all`;
        }
        return `${this.smartTable.selection.isSelected(row) ? 'deselect' : 'select'} row ${row.position + 1}`;
    }
}
SmarttableComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: SmarttableComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
SmarttableComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.7", type: SmarttableComponent, selector: "smarttable", inputs: { smartTable: "smartTable" }, ngImport: i0, template: "<table mat-table [dataSource]=\"smartTable.tableRows\" class=\"full-width\">\n    <!--- Note that these columns can be defined in any order.\n          The actual rendered columns are set as a property on the row definition\" -->\n\n    <!-- Column Descriptor -->\n    <div *ngIf=\"smartTable.tableType === tableType.INHERITED\">\n        <ng-container\n            *ngFor=\"let header of smartTable.tableHeaders; let i = index\"\n            matColumnDef=\"{{ header }}\"\n        >\n            <th mat-header-cell *matHeaderCellDef>\n                <div *ngIf=\"header === 'icon' || header === 'options'\"></div>\n                <div *ngIf=\"header !== 'icon' && header !== 'options'\">\n                    {{ smartTable.customTableHeaders[i] }}\n                </div>\n            </th>\n            <td mat-cell *matCellDef=\"let element\">\n                <mat-icon *ngIf=\"header === 'icon'\"> {{ element[header] }} </mat-icon>\n                <div *ngIf=\"header === 'options'\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\" aria-label=\"options\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button\n                            *ngFor=\"let option of smartTable.options\"\n                            mat-menu-item\n                            (click)=\"option.callback(element)\"\n                        >\n                            <mat-icon *ngIf=\"option.icon\">\n                                {{ option.icon }}\n                            </mat-icon>\n                            <span>\n                                {{ option.label }}\n                            </span>\n                        </button>\n                    </mat-menu>\n                </div>\n                <div *ngIf=\"header !== 'icon'\">\n                    {{ element[header] }}\n                </div>\n            </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"smartTable.tableHeaders; sticky: true\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: smartTable.tableHeaders\"></tr>\n    </div>\n    <div *ngIf=\"smartTable.tableType !== tableType.INHERITED\">\n        <!-- Checkbox Column -->\n        <ng-container matColumnDef=\"select\">\n            <th mat-header-cell *matHeaderCellDef>\n                <mat-checkbox\n                    (change)=\"$event ? toggleAllRows() : null\"\n                    [checked]=\"smartTable.selection!.hasValue() && isAllSelected()\"\n                    [indeterminate]=\"smartTable.selection!.hasValue() && !isAllSelected()\"\n                    [aria-label]=\"checkboxLabel()\"\n                >\n                </mat-checkbox>\n            </th>\n            <td mat-cell *matCellDef=\"let row\">\n                <mat-checkbox\n                    (click)=\"$event.stopPropagation()\"\n                    (change)=\"$event ? smartTable.selection!.toggle(row) : null\"\n                    [checked]=\"smartTable.selection!.isSelected(row)\"\n                    [aria-label]=\"checkboxLabel(row)\"\n                >\n                </mat-checkbox>\n            </td>\n        </ng-container>\n\n        <!-- Column Descriptor -->\n        <div *ngFor=\"let header of smartTable.tableHeaders\">\n            <ng-container *ngIf=\"header !== 'select'\" matColumnDef=\"{{ header }}\">\n                <th mat-header-cell *matHeaderCellDef>\n                    {{ header }}\n                </th>\n                <td mat-cell *matCellDef=\"let element\">{{ element[header] }}</td>\n            </ng-container>\n        </div>\n\n        <tr mat-header-row *matHeaderRowDef=\"smartTable.tableHeaders\"></tr>\n        <tr\n            mat-row\n            *matRowDef=\"let row; columns: smartTable.tableHeaders\"\n            (click)=\"smartTable.selection!.toggle(row)\"\n        ></tr>\n    </div>\n</table>\n", styles: [".full-width{width:100%}\n"], components: [{ type: i1.MatTable, selector: "mat-table, table[mat-table]", exportAs: ["matTable"] }, { type: i2.MatIcon, selector: "mat-icon", inputs: ["color", "inline", "svgIcon", "fontSet", "fontIcon"], exportAs: ["matIcon"] }, { type: i3.MatButton, selector: "button[mat-button], button[mat-raised-button], button[mat-icon-button],             button[mat-fab], button[mat-mini-fab], button[mat-stroked-button],             button[mat-flat-button]", inputs: ["disabled", "disableRipple", "color"], exportAs: ["matButton"] }, { type: i4.MatMenu, selector: "mat-menu", exportAs: ["matMenu"] }, { type: i4.MatMenuItem, selector: "[mat-menu-item]", inputs: ["disabled", "disableRipple", "role"], exportAs: ["matMenuItem"] }, { type: i1.MatHeaderRow, selector: "mat-header-row, tr[mat-header-row]", exportAs: ["matHeaderRow"] }, { type: i1.MatRow, selector: "mat-row, tr[mat-row]", exportAs: ["matRow"] }, { type: i5.MatCheckbox, selector: "mat-checkbox", inputs: ["disableRipple", "color", "tabIndex", "aria-label", "aria-labelledby", "aria-describedby", "id", "required", "labelPosition", "name", "value", "checked", "disabled", "indeterminate"], outputs: ["change", "indeterminateChange"], exportAs: ["matCheckbox"] }], directives: [{ type: i6.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { type: i6.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { type: i1.MatColumnDef, selector: "[matColumnDef]", inputs: ["sticky", "matColumnDef"] }, { type: i1.MatHeaderCellDef, selector: "[matHeaderCellDef]" }, { type: i1.MatHeaderCell, selector: "mat-header-cell, th[mat-header-cell]" }, { type: i1.MatCellDef, selector: "[matCellDef]" }, { type: i1.MatCell, selector: "mat-cell, td[mat-cell]" }, { type: i4.MatMenuTrigger, selector: "[mat-menu-trigger-for], [matMenuTriggerFor]", exportAs: ["matMenuTrigger"] }, { type: i1.MatHeaderRowDef, selector: "[matHeaderRowDef]", inputs: ["matHeaderRowDef", "matHeaderRowDefSticky"] }, { type: i1.MatRowDef, selector: "[matRowDef]", inputs: ["matRowDefColumns", "matRowDefWhen"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.7", ngImport: i0, type: SmarttableComponent, decorators: [{
            type: Component,
            args: [{ selector: 'smarttable', template: "<table mat-table [dataSource]=\"smartTable.tableRows\" class=\"full-width\">\n    <!--- Note that these columns can be defined in any order.\n          The actual rendered columns are set as a property on the row definition\" -->\n\n    <!-- Column Descriptor -->\n    <div *ngIf=\"smartTable.tableType === tableType.INHERITED\">\n        <ng-container\n            *ngFor=\"let header of smartTable.tableHeaders; let i = index\"\n            matColumnDef=\"{{ header }}\"\n        >\n            <th mat-header-cell *matHeaderCellDef>\n                <div *ngIf=\"header === 'icon' || header === 'options'\"></div>\n                <div *ngIf=\"header !== 'icon' && header !== 'options'\">\n                    {{ smartTable.customTableHeaders[i] }}\n                </div>\n            </th>\n            <td mat-cell *matCellDef=\"let element\">\n                <mat-icon *ngIf=\"header === 'icon'\"> {{ element[header] }} </mat-icon>\n                <div *ngIf=\"header === 'options'\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\" aria-label=\"options\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button\n                            *ngFor=\"let option of smartTable.options\"\n                            mat-menu-item\n                            (click)=\"option.callback(element)\"\n                        >\n                            <mat-icon *ngIf=\"option.icon\">\n                                {{ option.icon }}\n                            </mat-icon>\n                            <span>\n                                {{ option.label }}\n                            </span>\n                        </button>\n                    </mat-menu>\n                </div>\n                <div *ngIf=\"header !== 'icon'\">\n                    {{ element[header] }}\n                </div>\n            </td>\n        </ng-container>\n\n        <tr mat-header-row *matHeaderRowDef=\"smartTable.tableHeaders; sticky: true\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: smartTable.tableHeaders\"></tr>\n    </div>\n    <div *ngIf=\"smartTable.tableType !== tableType.INHERITED\">\n        <!-- Checkbox Column -->\n        <ng-container matColumnDef=\"select\">\n            <th mat-header-cell *matHeaderCellDef>\n                <mat-checkbox\n                    (change)=\"$event ? toggleAllRows() : null\"\n                    [checked]=\"smartTable.selection!.hasValue() && isAllSelected()\"\n                    [indeterminate]=\"smartTable.selection!.hasValue() && !isAllSelected()\"\n                    [aria-label]=\"checkboxLabel()\"\n                >\n                </mat-checkbox>\n            </th>\n            <td mat-cell *matCellDef=\"let row\">\n                <mat-checkbox\n                    (click)=\"$event.stopPropagation()\"\n                    (change)=\"$event ? smartTable.selection!.toggle(row) : null\"\n                    [checked]=\"smartTable.selection!.isSelected(row)\"\n                    [aria-label]=\"checkboxLabel(row)\"\n                >\n                </mat-checkbox>\n            </td>\n        </ng-container>\n\n        <!-- Column Descriptor -->\n        <div *ngFor=\"let header of smartTable.tableHeaders\">\n            <ng-container *ngIf=\"header !== 'select'\" matColumnDef=\"{{ header }}\">\n                <th mat-header-cell *matHeaderCellDef>\n                    {{ header }}\n                </th>\n                <td mat-cell *matCellDef=\"let element\">{{ element[header] }}</td>\n            </ng-container>\n        </div>\n\n        <tr mat-header-row *matHeaderRowDef=\"smartTable.tableHeaders\"></tr>\n        <tr\n            mat-row\n            *matRowDef=\"let row; columns: smartTable.tableHeaders\"\n            (click)=\"smartTable.selection!.toggle(row)\"\n        ></tr>\n    </div>\n</table>\n", styles: [".full-width{width:100%}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { smartTable: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic21hcnR0YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9zbWFydHRhYmxlL3NyYy9saWIvc21hcnR0YWJsZS5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9zbWFydHRhYmxlL3NyYy9saWIvc21hcnR0YWJsZS5jb21wb25lbnQuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUN6RCxPQUFPLEVBQWMsY0FBYyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7Ozs7O0FBT2hFLE1BQU0sT0FBTyxtQkFBbUI7SUFJL0I7UUFGQSxjQUFTLEdBQUcsY0FBYyxDQUFDO0lBRVosQ0FBQztJQUVoQixRQUFRLEtBQVUsQ0FBQztJQUVuQixhQUFhO1FBQ1osTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxTQUFVLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQztRQUMvRCxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUM7UUFDakQsT0FBTyxXQUFXLEtBQUssT0FBTyxDQUFDO0lBQ2hDLENBQUM7SUFFRCxnRkFBZ0Y7SUFDaEYsYUFBYTtRQUNaLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRSxFQUFFO1lBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBVSxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ25DLE9BQU87U0FDUDtRQUVELElBQUksQ0FBQyxVQUFVLENBQUMsU0FBVSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDakUsQ0FBQztJQUVELG1EQUFtRDtJQUNuRCxhQUFhLENBQUMsR0FBUztRQUN0QixJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1QsT0FBTyxHQUFHLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUFRLE1BQU0sQ0FBQztTQUM3RDtRQUNELE9BQU8sR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVUsQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUMsUUFBUSxRQUMzRSxHQUFHLENBQUMsUUFBUSxHQUFHLENBQ2hCLEVBQUUsQ0FBQztJQUNKLENBQUM7O2dIQWhDVyxtQkFBbUI7b0dBQW5CLG1CQUFtQix3RkNSaEMsODNIQXVGQTsyRkQvRWEsbUJBQW1CO2tCQUwvQixTQUFTOytCQUNDLFlBQVk7MEVBS2IsVUFBVTtzQkFBbEIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU21hcnRUYWJsZSwgU21hcnRUYWJsZVR5cGUgfSBmcm9tICcuL3NtYXJ0dGFibGUubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdzbWFydHRhYmxlJyxcblx0dGVtcGxhdGVVcmw6ICcuL3NtYXJ0dGFibGUuY29tcG9uZW50Lmh0bWwnLFxuXHRzdHlsZVVybHM6IFsnLi9zbWFydHRhYmxlLmNvbXBvbmVudC5jc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBTbWFydHRhYmxlQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0IHtcblx0QElucHV0KCkgc21hcnRUYWJsZSE6IFNtYXJ0VGFibGU8YW55Pjtcblx0dGFibGVUeXBlID0gU21hcnRUYWJsZVR5cGU7XG5cblx0Y29uc3RydWN0b3IoKSB7fVxuXG5cdG5nT25Jbml0KCk6IHZvaWQge31cblxuXHRpc0FsbFNlbGVjdGVkKCkge1xuXHRcdGNvbnN0IG51bVNlbGVjdGVkID0gdGhpcy5zbWFydFRhYmxlLnNlbGVjdGlvbiEuc2VsZWN0ZWQubGVuZ3RoO1xuXHRcdGNvbnN0IG51bVJvd3MgPSB0aGlzLnNtYXJ0VGFibGUudGFibGVSb3dzLmxlbmd0aDtcblx0XHRyZXR1cm4gbnVtU2VsZWN0ZWQgPT09IG51bVJvd3M7XG5cdH1cblxuXHQvKiogU2VsZWN0cyBhbGwgcm93cyBpZiB0aGV5IGFyZSBub3QgYWxsIHNlbGVjdGVkOyBvdGhlcndpc2UgY2xlYXIgc2VsZWN0aW9uLiAqL1xuXHR0b2dnbGVBbGxSb3dzKCkge1xuXHRcdGlmICh0aGlzLmlzQWxsU2VsZWN0ZWQoKSkge1xuXHRcdFx0dGhpcy5zbWFydFRhYmxlLnNlbGVjdGlvbiEuY2xlYXIoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnNtYXJ0VGFibGUuc2VsZWN0aW9uIS5zZWxlY3QoLi4udGhpcy5zbWFydFRhYmxlLnRhYmxlUm93cyk7XG5cdH1cblxuXHQvKiogVGhlIGxhYmVsIGZvciB0aGUgY2hlY2tib3ggb24gdGhlIHBhc3NlZCByb3cgKi9cblx0Y2hlY2tib3hMYWJlbChyb3c/OiBhbnkpOiBzdHJpbmcge1xuXHRcdGlmICghcm93KSB7XG5cdFx0XHRyZXR1cm4gYCR7dGhpcy5pc0FsbFNlbGVjdGVkKCkgPyAnZGVzZWxlY3QnIDogJ3NlbGVjdCd9IGFsbGA7XG5cdFx0fVxuXHRcdHJldHVybiBgJHt0aGlzLnNtYXJ0VGFibGUuc2VsZWN0aW9uIS5pc1NlbGVjdGVkKHJvdykgPyAnZGVzZWxlY3QnIDogJ3NlbGVjdCd9IHJvdyAke1xuXHRcdFx0cm93LnBvc2l0aW9uICsgMVxuXHRcdH1gO1xuXHR9XG59XG4iLCI8dGFibGUgbWF0LXRhYmxlIFtkYXRhU291cmNlXT1cInNtYXJ0VGFibGUudGFibGVSb3dzXCIgY2xhc3M9XCJmdWxsLXdpZHRoXCI+XG4gICAgPCEtLS0gTm90ZSB0aGF0IHRoZXNlIGNvbHVtbnMgY2FuIGJlIGRlZmluZWQgaW4gYW55IG9yZGVyLlxuICAgICAgICAgIFRoZSBhY3R1YWwgcmVuZGVyZWQgY29sdW1ucyBhcmUgc2V0IGFzIGEgcHJvcGVydHkgb24gdGhlIHJvdyBkZWZpbml0aW9uXCIgLS0+XG5cbiAgICA8IS0tIENvbHVtbiBEZXNjcmlwdG9yIC0tPlxuICAgIDxkaXYgKm5nSWY9XCJzbWFydFRhYmxlLnRhYmxlVHlwZSA9PT0gdGFibGVUeXBlLklOSEVSSVRFRFwiPlxuICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdGb3I9XCJsZXQgaGVhZGVyIG9mIHNtYXJ0VGFibGUudGFibGVIZWFkZXJzOyBsZXQgaSA9IGluZGV4XCJcbiAgICAgICAgICAgIG1hdENvbHVtbkRlZj1cInt7IGhlYWRlciB9fVwiXG4gICAgICAgID5cbiAgICAgICAgICAgIDx0aCBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWY+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhlYWRlciA9PT0gJ2ljb24nIHx8IGhlYWRlciA9PT0gJ29wdGlvbnMnXCI+PC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiAqbmdJZj1cImhlYWRlciAhPT0gJ2ljb24nICYmIGhlYWRlciAhPT0gJ29wdGlvbnMnXCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IHNtYXJ0VGFibGUuY3VzdG9tVGFibGVIZWFkZXJzW2ldIH19XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgPHRkIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnRcIj5cbiAgICAgICAgICAgICAgICA8bWF0LWljb24gKm5nSWY9XCJoZWFkZXIgPT09ICdpY29uJ1wiPiB7eyBlbGVtZW50W2hlYWRlcl0gfX0gPC9tYXQtaWNvbj5cbiAgICAgICAgICAgICAgICA8ZGl2ICpuZ0lmPVwiaGVhZGVyID09PSAnb3B0aW9ucydcIj5cbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBtYXQtaWNvbi1idXR0b24gW21hdE1lbnVUcmlnZ2VyRm9yXT1cIm1lbnVcIiBhcmlhLWxhYmVsPVwib3B0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPG1hdC1pY29uPm1vcmVfdmVydDwvbWF0LWljb24+XG4gICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8bWF0LW1lbnUgI21lbnU9XCJtYXRNZW51XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nRm9yPVwibGV0IG9wdGlvbiBvZiBzbWFydFRhYmxlLm9wdGlvbnNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdC1tZW51LWl0ZW1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwib3B0aW9uLmNhbGxiYWNrKGVsZW1lbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWljb24gKm5nSWY9XCJvcHRpb24uaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyBvcHRpb24uaWNvbiB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbWF0LWljb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IG9wdGlvbi5sYWJlbCB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L21hdC1tZW51PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDxkaXYgKm5nSWY9XCJoZWFkZXIgIT09ICdpY29uJ1wiPlxuICAgICAgICAgICAgICAgICAgICB7eyBlbGVtZW50W2hlYWRlcl0gfX1cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgIDwvbmctY29udGFpbmVyPlxuXG4gICAgICAgIDx0ciBtYXQtaGVhZGVyLXJvdyAqbWF0SGVhZGVyUm93RGVmPVwic21hcnRUYWJsZS50YWJsZUhlYWRlcnM7IHN0aWNreTogdHJ1ZVwiPjwvdHI+XG4gICAgICAgIDx0ciBtYXQtcm93ICptYXRSb3dEZWY9XCJsZXQgcm93OyBjb2x1bW5zOiBzbWFydFRhYmxlLnRhYmxlSGVhZGVyc1wiPjwvdHI+XG4gICAgPC9kaXY+XG4gICAgPGRpdiAqbmdJZj1cInNtYXJ0VGFibGUudGFibGVUeXBlICE9PSB0YWJsZVR5cGUuSU5IRVJJVEVEXCI+XG4gICAgICAgIDwhLS0gQ2hlY2tib3ggQ29sdW1uIC0tPlxuICAgICAgICA8bmctY29udGFpbmVyIG1hdENvbHVtbkRlZj1cInNlbGVjdFwiPlxuICAgICAgICAgICAgPHRoIG1hdC1oZWFkZXItY2VsbCAqbWF0SGVhZGVyQ2VsbERlZj5cbiAgICAgICAgICAgICAgICA8bWF0LWNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgIChjaGFuZ2UpPVwiJGV2ZW50ID8gdG9nZ2xlQWxsUm93cygpIDogbnVsbFwiXG4gICAgICAgICAgICAgICAgICAgIFtjaGVja2VkXT1cInNtYXJ0VGFibGUuc2VsZWN0aW9uIS5oYXNWYWx1ZSgpICYmIGlzQWxsU2VsZWN0ZWQoKVwiXG4gICAgICAgICAgICAgICAgICAgIFtpbmRldGVybWluYXRlXT1cInNtYXJ0VGFibGUuc2VsZWN0aW9uIS5oYXNWYWx1ZSgpICYmICFpc0FsbFNlbGVjdGVkKClcIlxuICAgICAgICAgICAgICAgICAgICBbYXJpYS1sYWJlbF09XCJjaGVja2JveExhYmVsKClcIlxuICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICA8L21hdC1jaGVja2JveD5cbiAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICA8dGQgbWF0LWNlbGwgKm1hdENlbGxEZWY9XCJsZXQgcm93XCI+XG4gICAgICAgICAgICAgICAgPG1hdC1jaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpXCJcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCIkZXZlbnQgPyBzbWFydFRhYmxlLnNlbGVjdGlvbiEudG9nZ2xlKHJvdykgOiBudWxsXCJcbiAgICAgICAgICAgICAgICAgICAgW2NoZWNrZWRdPVwic21hcnRUYWJsZS5zZWxlY3Rpb24hLmlzU2VsZWN0ZWQocm93KVwiXG4gICAgICAgICAgICAgICAgICAgIFthcmlhLWxhYmVsXT1cImNoZWNrYm94TGFiZWwocm93KVwiXG4gICAgICAgICAgICAgICAgPlxuICAgICAgICAgICAgICAgIDwvbWF0LWNoZWNrYm94PlxuICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgICAgPCEtLSBDb2x1bW4gRGVzY3JpcHRvciAtLT5cbiAgICAgICAgPGRpdiAqbmdGb3I9XCJsZXQgaGVhZGVyIG9mIHNtYXJ0VGFibGUudGFibGVIZWFkZXJzXCI+XG4gICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiaGVhZGVyICE9PSAnc2VsZWN0J1wiIG1hdENvbHVtbkRlZj1cInt7IGhlYWRlciB9fVwiPlxuICAgICAgICAgICAgICAgIDx0aCBtYXQtaGVhZGVyLWNlbGwgKm1hdEhlYWRlckNlbGxEZWY+XG4gICAgICAgICAgICAgICAgICAgIHt7IGhlYWRlciB9fVxuICAgICAgICAgICAgICAgIDwvdGg+XG4gICAgICAgICAgICAgICAgPHRkIG1hdC1jZWxsICptYXRDZWxsRGVmPVwibGV0IGVsZW1lbnRcIj57eyBlbGVtZW50W2hlYWRlcl0gfX08L3RkPlxuICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDx0ciBtYXQtaGVhZGVyLXJvdyAqbWF0SGVhZGVyUm93RGVmPVwic21hcnRUYWJsZS50YWJsZUhlYWRlcnNcIj48L3RyPlxuICAgICAgICA8dHJcbiAgICAgICAgICAgIG1hdC1yb3dcbiAgICAgICAgICAgICptYXRSb3dEZWY9XCJsZXQgcm93OyBjb2x1bW5zOiBzbWFydFRhYmxlLnRhYmxlSGVhZGVyc1wiXG4gICAgICAgICAgICAoY2xpY2spPVwic21hcnRUYWJsZS5zZWxlY3Rpb24hLnRvZ2dsZShyb3cpXCJcbiAgICAgICAgPjwvdHI+XG4gICAgPC9kaXY+XG48L3RhYmxlPlxuIl19