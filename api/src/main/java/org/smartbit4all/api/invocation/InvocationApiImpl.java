package org.smartbit4all.api.invocation;

import java.lang.reflect.Method;
import java.net.URI;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.smartbit4all.api.collection.CollectionApi;
import org.smartbit4all.api.invocation.bean.ApiData;
import org.smartbit4all.api.invocation.bean.AsyncInvocationRequest;
import org.smartbit4all.api.invocation.bean.InvocationParameter;
import org.smartbit4all.api.invocation.bean.InvocationRequest;
import org.smartbit4all.api.session.SessionApi;
import org.smartbit4all.api.session.SessionManagementApi;
import org.smartbit4all.core.object.ObjectApi;
import org.smartbit4all.domain.application.ApplicationRuntime;
import org.smartbit4all.domain.application.ApplicationRuntimeApi;
import org.smartbit4all.storage.fs.StorageTransactionManagerFS;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.util.CollectionUtils;

/**
 * The implementation of the {@link InvocationApi}. It collects all the
 * {@link InvocationExecutionApi} we have. If we call the {@link #invoke(InvocationRequest)} then
 * there is routing to the appropriate execution api. We always have a local execution api
 * 
 * @author Peter Boros
 */
public final class InvocationApiImpl implements InvocationApi, DisposableBean {

  @Autowired
  private InvocationRegisterApi invocationRegisterApi;

  @Autowired(required = false)
  private ApplicationRuntimeApi applicationRuntimeApi;

  @Autowired(required = false)
  private SessionManagementApi sessionManagementApi;

  @Autowired(required = false)
  private SessionApi sessionApi;

  @Autowired
  private CollectionApi collectionApi;

  @Autowired
  private InvocationApi self;

  @Autowired
  private ObjectApi objectApi;

  /**
   * The {@link InvocationExecutionApi} is for handling remote calls.
   */
  @Autowired(required = false)
  private InvocationExecutionApi executionApi;

  /**
   * All the asynchronous channels we have in the current configuration.
   */
  @Autowired(required = false)
  private List<AsyncInvocationChannel> channels;

  /**
   * The transaction manager (there must be only one in one application) that is configured. Used to
   * identify if there is an active transaction initiated on the current {@link Thread}. The lock of
   * the objects are collected in the {@link #transactionManager} and at the end of the transaction
   * all of them are finalized. The finalize is nothing else but the atomic move of the temporary
   * files generated by the transaction.
   */
  @Autowired(required = false)
  private StorageTransactionManagerFS transactionManager;

  private Map<String, AsyncInvocationChannel> channelsByName;

  @Override
  public InvocationParameter invoke(InvocationRequest request) throws ApiNotFoundException {
    ApiDescriptor apiDescriptor =
        invocationRegisterApi.getApi(request.getInterfaceClass(), request.getName());

    if (apiDescriptor == null) {
      throw new ApiNotFoundException(request);
    }

    return invoke(apiDescriptor, request);
  }

  private InvocationParameter invoke(ApiDescriptor apiDescriptor, InvocationRequest request)
      throws ApiNotFoundException {

    ApiData apiData = apiDescriptor.getApiData();
    List<UUID> runtimes = invocationRegisterApi.getRuntimesForApi(apiData.getUri());

    if (CollectionUtils.isEmpty(runtimes)) {
      throw new ApiNotFoundException(apiData);
    }

    // If the applicationRuntimeApi is null, then we can only invoke the api call in our own runtime
    if (applicationRuntimeApi == null
        || runtimes.contains(applicationRuntimeApi.self().getUuid())) {
      Object apiInstance = invocationRegisterApi.getApiInstance(apiData.getUri());
      Method method = Invocations.getMethodToCall(apiInstance, request);
      return Invocations.invokeMethod(request, apiInstance, method);
    } else {
      UUID runtimeToRun = getRuntimeToRun(runtimes);

      return executionApi.invoke(runtimeToRun, request);
    }
  }

  @EventListener(ApplicationReadyEvent.class)
  public void init() {
    invocationRegisterApi.setInvocationApi(this);
    channelsByName = new HashMap<>();
    if (channels != null) {
      for (AsyncInvocationChannel channel : channels) {
        AsyncInvocationChannelSetup channelSetup = (AsyncInvocationChannelSetup) channel;
        channelSetup.invocationApi(self);
        channelSetup.collectionApi(collectionApi);
        channelSetup.setSessionManagementApi(sessionManagementApi);
        channelSetup.start();
        channelsByName.put(channel.getName(), channel);
      }
    }
  }

  private UUID getRuntimeToRun(List<UUID> runtimes) {
    // TODO decide which runtime to use
    return runtimes.get(0);
  }

  @Override
  public <T> InvocationBuilder<T> builder(Class<T> apiInterface) {
    return new InvocationBuilder<>(apiInterface).sessionApi(sessionApi);
  }

  @Override
  public void invokeAsync(InvocationRequest request, String channel) {
    AsyncInvocationChannel asyncInvocationChannel = channelsByName.get(channel);
    if (asyncInvocationChannel == null) {
      throw new IllegalArgumentException(
          "Unable to find the " + channel + " asynchronous execution channel.");
    }
    AsyncInvocationRequest asyncInvocationRequest = new AsyncInvocationRequest().request(request);

    if (transactionManager != null && transactionManager.isInTransaction()) {
      if (applicationRuntimeApi != null) {
        // Save the request to remember to execute if this runtime fails. We set the runtime
        // identifier
        // to see which runtime is responsible for the invocation currently.
        ApplicationRuntime applicationRuntime = applicationRuntimeApi.self();
        asyncInvocationRequest.runtimeUri(applicationRuntime.getUri());
        asyncInvocationRequest
            .setUri(objectApi.saveAsNew(Invocations.INVOCATION_SCHEME, asyncInvocationRequest));
        // We save the given invocation into a list related to the application runtime.
        collectionApi
            .list(applicationRuntime.getUri(), Invocations.INVOCATION_SCHEME, channel)
            .add(asyncInvocationRequest.getUri());
      }
      transactionManager.addOnSucceed(asyncInvocationChannel, asyncInvocationRequest);
    } else {
      asyncInvocationChannel.invoke(asyncInvocationRequest);
    }
  }

  @Override
  public void destroy() throws Exception {
    for (AsyncInvocationChannel channel : channelsByName.values()) {
      AsyncInvocationChannelSetup channelSetup = (AsyncInvocationChannelSetup) channel;
      channelSetup.stop();
    }
  }

  @Override
  public void subscribe(InvocationRequest request, URI objectUri) {
    // TODO Auto-generated method stub

  }

  @Override
  public void subscribeAsync(InvocationRequest request, String channel, URI objectUri) {
    // TODO Auto-generated method stub

  }

}
