package org.smartbit4all.api.invocation;

import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.smartbit4all.api.invocation.bean.ApiData;
import org.smartbit4all.api.invocation.bean.InvocationParameter;
import org.smartbit4all.api.invocation.bean.InvocationRequest;
import org.smartbit4all.api.session.SessionApi;
import org.smartbit4all.api.session.SessionManagementApi;
import org.smartbit4all.domain.application.ApplicationRuntimeApi;
import org.smartbit4all.storage.fs.StorageTransactionManagerFS;
import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.util.CollectionUtils;

/**
 * The implementation of the {@link InvocationApi}. It collects all the
 * {@link InvocationExecutionApi} we have. If we call the {@link #invoke(InvocationRequest)} then
 * there is routing to the appropriate execution api. We always have a local execution api
 * 
 * @author Peter Boros
 */
public final class InvocationApiImpl implements InvocationApi, DisposableBean {

  @Autowired
  private InvocationRegisterApi invocationRegisterApi;

  @Autowired(required = false)
  private ApplicationRuntimeApi applicationRuntimeApi;

  @Autowired(required = false)
  private SessionManagementApi sessionManagementApi;

  @Autowired(required = false)
  private SessionApi sessionApi;

  /**
   * The {@link InvocationExecutionApi} is for handling remote calls.
   */
  @Autowired(required = false)
  private InvocationExecutionApi executionApi;

  /**
   * All the asynchronous channels we have in the current configuration.
   */
  @Autowired(required = false)
  private List<AsyncInvocationChannel> channels;

  /**
   * The transaction manager (there must be only one in one application) that is configured. Used to
   * identify if there is an active transaction initiated on the current {@link Thread}. The lock of
   * the objects are collected in the {@link #transactionManager} and at the end of the transaction
   * all of them are finalized. The finalize is nothing else but the atomic move of the temporary
   * files generated by the transaction.
   */
  @Autowired(required = false)
  private StorageTransactionManagerFS transactionManager;

  private Map<String, AsyncInvocationChannel> channelsByName;

  @Override
  public InvocationParameter invoke(InvocationRequest request) throws ApiNotFoundException {
    ApiDescriptor apiDescriptor =
        invocationRegisterApi.getApi(request.getInterfaceClass(), request.getName());

    if (apiDescriptor == null) {
      throw new ApiNotFoundException(request);
    }

    return invoke(apiDescriptor, request);
  }

  private InvocationParameter invoke(ApiDescriptor apiDescriptor, InvocationRequest request)
      throws ApiNotFoundException {

    ApiData apiData = apiDescriptor.getApiData();
    List<UUID> runtimes = invocationRegisterApi.getRuntimesForApi(apiData.getUri());

    if (CollectionUtils.isEmpty(runtimes)) {
      throw new ApiNotFoundException(apiData);
    }

    // If the applicationRuntimeApi is null, then we can only invoke the api call in our own runtime
    if (applicationRuntimeApi == null
        || runtimes.contains(applicationRuntimeApi.self().getUuid())) {
      Object apiInstance = invocationRegisterApi.getApiInstance(apiData.getUri());
      Method method = Invocations.getMethodToCall(apiInstance, request);
      return Invocations.invokeMethod(request, apiInstance, method);
    } else {
      UUID runtimeToRun = getRuntimeToRun(runtimes);

      return executionApi.invoke(runtimeToRun, request);
    }
  }

  @EventListener(ApplicationReadyEvent.class)
  public void init() {
    invocationRegisterApi.setInvocationApi(this);
    channelsByName = new HashMap<>();
    if (channels != null) {
      for (AsyncInvocationChannel channel : channels) {
        channel.invocationApi(this);
        channel.setSessionManagementApi(sessionManagementApi);
        channel.start();
        channelsByName.put(channel.getName(), channel);
      }
    }
  }

  private UUID getRuntimeToRun(List<UUID> runtimes) {
    // TODO decide which runtime to use
    return runtimes.get(0);
  }

  @Override
  public <T> InvocationBuilder<T> builder(Class<T> apiInterface) {
    return new InvocationBuilder<>(apiInterface).sessionApi(sessionApi);
  }

  @Override
  public void invokeAsync(InvocationRequest request, String channel) {
    AsyncInvocationChannel asyncInvocationChannel = channelsByName.get(channel);
    if (asyncInvocationChannel != null) {
      if (transactionManager != null && transactionManager.isInTransaction()) {
        transactionManager.addOnSucceed(asyncInvocationChannel, request);
      } else {
        asyncInvocationChannel.invoke(request);
      }
    }
  }

  @Override
  public void destroy() throws Exception {
    for (AsyncInvocationChannel asyncInvocationChannel : channelsByName.values()) {
      asyncInvocationChannel.stop();
    }
  }

}
